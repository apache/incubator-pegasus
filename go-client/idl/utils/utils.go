// Autogenerated by Thrift Compiler (0.13.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package utils

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
	"reflect"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = reflect.DeepEqual
var _ = bytes.Equal

type PatternMatchType int64

const (
	PatternMatchType_PMT_INVALID        PatternMatchType = 0
	PatternMatchType_PMT_MATCH_ALL      PatternMatchType = 1
	PatternMatchType_PMT_MATCH_EXACT    PatternMatchType = 2
	PatternMatchType_PMT_MATCH_ANYWHERE PatternMatchType = 3
	PatternMatchType_PMT_MATCH_PREFIX   PatternMatchType = 4
	PatternMatchType_PMT_MATCH_POSTFIX  PatternMatchType = 5
	PatternMatchType_PMT_MATCH_REGEX    PatternMatchType = 6
)

func (p PatternMatchType) String() string {
	switch p {
	case PatternMatchType_PMT_INVALID:
		return "PMT_INVALID"
	case PatternMatchType_PMT_MATCH_ALL:
		return "PMT_MATCH_ALL"
	case PatternMatchType_PMT_MATCH_EXACT:
		return "PMT_MATCH_EXACT"
	case PatternMatchType_PMT_MATCH_ANYWHERE:
		return "PMT_MATCH_ANYWHERE"
	case PatternMatchType_PMT_MATCH_PREFIX:
		return "PMT_MATCH_PREFIX"
	case PatternMatchType_PMT_MATCH_POSTFIX:
		return "PMT_MATCH_POSTFIX"
	case PatternMatchType_PMT_MATCH_REGEX:
		return "PMT_MATCH_REGEX"
	}
	return "<UNSET>"
}

func PatternMatchTypeFromString(s string) (PatternMatchType, error) {
	switch s {
	case "PMT_INVALID":
		return PatternMatchType_PMT_INVALID, nil
	case "PMT_MATCH_ALL":
		return PatternMatchType_PMT_MATCH_ALL, nil
	case "PMT_MATCH_EXACT":
		return PatternMatchType_PMT_MATCH_EXACT, nil
	case "PMT_MATCH_ANYWHERE":
		return PatternMatchType_PMT_MATCH_ANYWHERE, nil
	case "PMT_MATCH_PREFIX":
		return PatternMatchType_PMT_MATCH_PREFIX, nil
	case "PMT_MATCH_POSTFIX":
		return PatternMatchType_PMT_MATCH_POSTFIX, nil
	case "PMT_MATCH_REGEX":
		return PatternMatchType_PMT_MATCH_REGEX, nil
	}
	return PatternMatchType(0), fmt.Errorf("not a valid PatternMatchType string")
}

func PatternMatchTypePtr(v PatternMatchType) *PatternMatchType { return &v }

func (p PatternMatchType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *PatternMatchType) UnmarshalText(text []byte) error {
	q, err := PatternMatchTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *PatternMatchType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = PatternMatchType(v)
	return nil
}

func (p *PatternMatchType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type ChecksumType int64

const (
	ChecksumType_CST_INVALID ChecksumType = 0
	ChecksumType_CST_NONE    ChecksumType = 1
	ChecksumType_CST_MD5     ChecksumType = 2
)

func (p ChecksumType) String() string {
	switch p {
	case ChecksumType_CST_INVALID:
		return "CST_INVALID"
	case ChecksumType_CST_NONE:
		return "CST_NONE"
	case ChecksumType_CST_MD5:
		return "CST_MD5"
	}
	return "<UNSET>"
}

func ChecksumTypeFromString(s string) (ChecksumType, error) {
	switch s {
	case "CST_INVALID":
		return ChecksumType_CST_INVALID, nil
	case "CST_NONE":
		return ChecksumType_CST_NONE, nil
	case "CST_MD5":
		return ChecksumType_CST_MD5, nil
	}
	return ChecksumType(0), fmt.Errorf("not a valid ChecksumType string")
}

func ChecksumTypePtr(v ChecksumType) *ChecksumType { return &v }

func (p ChecksumType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ChecksumType) UnmarshalText(text []byte) error {
	q, err := ChecksumTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *ChecksumType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = ChecksumType(v)
	return nil
}

func (p *ChecksumType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}
