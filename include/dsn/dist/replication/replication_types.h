/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef replication_TYPES_H
#define replication_TYPES_H

#include <dsn/service_api_cpp.h>
#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace dsn { namespace replication {

enum partition_status {
    PS_INVALID = 0,
    PS_INACTIVE = 1,
    PS_ERROR = 2,
    PS_PRIMARY = 3,
    PS_SECONDARY = 4,
    PS_POTENTIAL_SECONDARY = 5
};


enum read_semantic {
    ReadInvalid = 0,
    ReadLastUpdate = 1,
    ReadOutdated = 2,
    ReadSnapshot = 3
};


enum learn_type {
    LT_INVALID = 0,
    LT_CACHE = 1,
    LT_APP = 2,
    LT_LOG = 3
};


enum learner_status {
    LearningInvalid = 0,
    LearningWithoutPrepare = 1,
    LearningWithPrepareTransient = 2,
    LearningWithPrepare = 3,
    LearningSucceeded = 4,
    LearningFailed = 5
};


enum config_type {
    CT_INVALID = 0,
    CT_ASSIGN_PRIMARY = 1,
    CT_UPGRADE_TO_PRIMARY = 2,
    CT_ADD_SECONDARY = 3,
    CT_UPGRADE_TO_SECONDARY = 4,
    CT_DOWNGRADE_TO_SECONDARY = 5,
    CT_DOWNGRADE_TO_INACTIVE = 6,
    CT_REMOVE = 7,
    CT_ADD_SECONDARY_FOR_LB = 8
};


enum app_status {
    AS_INVALID = 0,
    AS_AVAILABLE = 1,
    AS_CREATING = 2,
    AS_CREATE_FAILED = 3,
    AS_DROPPING = 4,
    AS_DROP_FAILED = 5,
    AS_DROPPED = 6
};


enum node_status {
    NS_INVALID = 0,
    NS_ALIVE = 1,
    NS_UNALIVE = 2
};


enum balancer_type {
    BT_INVALID = 0,
    BT_MOVE_PRIMARY = 1,
    BT_COPY_PRIMARY = 2,
    BT_COPY_SECONDARY = 3
};


class global_partition_id;

class mutation_header;

class mutation_update;

class mutation_data;

class partition_configuration;

class replica_configuration;

class prepare_msg;

class read_request_header;

class write_request_header;

class rw_response_header;

class prepare_ack;

class learn_state;

class learn_request;

class learn_response;

class group_check_request;

class group_check_response;

class app_info;

class node_info;

class meta_response_header;

class configuration_update_request;

class configuration_update_response;

class configuration_proposal_request;

class configuration_query_by_node_request;

class create_app_options;

class configuration_create_app_request;

class drop_app_options;

class configuration_drop_app_request;

class configuration_list_apps_request;

class configuration_list_nodes_request;

class configuration_create_app_response;

class control_balancer_migration_request;

class control_balancer_migration_response;

class balancer_proposal_request;

class balancer_proposal_response;

class configuration_drop_app_response;

class configuration_list_apps_response;

class configuration_list_nodes_response;

class configuration_query_by_node_response;

class configuration_query_by_index_request;

class configuration_query_by_index_response;

class query_replica_decree_request;

class query_replica_decree_response;

class replica_info;

class query_replica_info_request;

class query_replica_info_response;

typedef struct _global_partition_id__isset {
  _global_partition_id__isset() : app_id(true), pidx(true) {}
  bool app_id :1;
  bool pidx :1;
} _global_partition_id__isset;

class global_partition_id {
 public:
  global_partition_id(int32_t _app_id, int32_t _pidx): app_id(_app_id), pidx(_pidx) {
  }

  global_partition_id(const global_partition_id&);
  global_partition_id& operator=(const global_partition_id&);
  global_partition_id() : app_id(-1), pidx(-1) {
  }

  virtual ~global_partition_id() throw();
  int32_t app_id;
  int32_t pidx;

  _global_partition_id__isset __isset;

  void __set_app_id(const int32_t val);

  void __set_pidx(const int32_t val);

  bool operator == (const global_partition_id & rhs) const
  {
    if (!(app_id == rhs.app_id))
      return false;
    if (!(pidx == rhs.pidx))
      return false;
    return true;
  }
  bool operator != (const global_partition_id &rhs) const {
    return !(*this == rhs);
  }


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(global_partition_id &a, global_partition_id &b);

inline std::ostream& operator<<(std::ostream& out, const global_partition_id& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _mutation_header__isset {
  _mutation_header__isset() : gpid(false), ballot(false), decree(false), log_offset(false), last_committed_decree(false) {}
  bool gpid :1;
  bool ballot :1;
  bool decree :1;
  bool log_offset :1;
  bool last_committed_decree :1;
} _mutation_header__isset;

class mutation_header {
 public:

  mutation_header(const mutation_header&);
  mutation_header& operator=(const mutation_header&);
  mutation_header() : ballot(0), decree(0), log_offset(0), last_committed_decree(0) {
  }

  virtual ~mutation_header() throw();
  global_partition_id gpid;
  int64_t ballot;
  int64_t decree;
  int64_t log_offset;
  int64_t last_committed_decree;

  _mutation_header__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_ballot(const int64_t val);

  void __set_decree(const int64_t val);

  void __set_log_offset(const int64_t val);

  void __set_last_committed_decree(const int64_t val);

  bool operator == (const mutation_header & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(decree == rhs.decree))
      return false;
    if (!(log_offset == rhs.log_offset))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    return true;
  }
  bool operator != (const mutation_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(mutation_header &a, mutation_header &b);

inline std::ostream& operator<<(std::ostream& out, const mutation_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _mutation_update__isset {
  _mutation_update__isset() : code(false), data(false) {}
  bool code :1;
  bool data :1;
} _mutation_update__isset;

class mutation_update {
 public:

  mutation_update(const mutation_update&);
  mutation_update& operator=(const mutation_update&);
  mutation_update() {
  }

  virtual ~mutation_update() throw();
   ::dsn::task_code code;
   ::dsn::blob data;

  _mutation_update__isset __isset;

  void __set_code(const  ::dsn::task_code& val);

  void __set_data(const  ::dsn::blob& val);

  bool operator == (const mutation_update & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const mutation_update &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_update & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(mutation_update &a, mutation_update &b);

inline std::ostream& operator<<(std::ostream& out, const mutation_update& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _mutation_data__isset {
  _mutation_data__isset() : header(false), updates(false) {}
  bool header :1;
  bool updates :1;
} _mutation_data__isset;

class mutation_data {
 public:

  mutation_data(const mutation_data&);
  mutation_data& operator=(const mutation_data&);
  mutation_data() {
  }

  virtual ~mutation_data() throw();
  mutation_header header;
  std::vector<mutation_update>  updates;

  _mutation_data__isset __isset;

  void __set_header(const mutation_header& val);

  void __set_updates(const std::vector<mutation_update> & val);

  bool operator == (const mutation_data & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    if (!(updates == rhs.updates))
      return false;
    return true;
  }
  bool operator != (const mutation_data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_data & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(mutation_data &a, mutation_data &b);

inline std::ostream& operator<<(std::ostream& out, const mutation_data& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _partition_configuration__isset {
  _partition_configuration__isset() : app_type(false), gpid(false), ballot(false), max_replica_count(false), primary(false), secondaries(false), last_drops(false), last_committed_decree(false) {}
  bool app_type :1;
  bool gpid :1;
  bool ballot :1;
  bool max_replica_count :1;
  bool primary :1;
  bool secondaries :1;
  bool last_drops :1;
  bool last_committed_decree :1;
} _partition_configuration__isset;

class partition_configuration {
 public:

  partition_configuration(const partition_configuration&);
  partition_configuration& operator=(const partition_configuration&);
  partition_configuration() : app_type(), ballot(0), max_replica_count(0), last_committed_decree(0) {
  }

  virtual ~partition_configuration() throw();
  std::string app_type;
  global_partition_id gpid;
  int64_t ballot;
  int32_t max_replica_count;
   ::dsn::rpc_address primary;
  std::vector< ::dsn::rpc_address>  secondaries;
  std::vector< ::dsn::rpc_address>  last_drops;
  int64_t last_committed_decree;

  _partition_configuration__isset __isset;

  void __set_app_type(const std::string& val);

  void __set_gpid(const global_partition_id& val);

  void __set_ballot(const int64_t val);

  void __set_max_replica_count(const int32_t val);

  void __set_primary(const  ::dsn::rpc_address& val);

  void __set_secondaries(const std::vector< ::dsn::rpc_address> & val);

  void __set_last_drops(const std::vector< ::dsn::rpc_address> & val);

  void __set_last_committed_decree(const int64_t val);

  bool operator == (const partition_configuration & rhs) const
  {
    if (!(app_type == rhs.app_type))
      return false;
    if (!(gpid == rhs.gpid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(max_replica_count == rhs.max_replica_count))
      return false;
    if (!(primary == rhs.primary))
      return false;
    if (!(secondaries == rhs.secondaries))
      return false;
    if (!(last_drops == rhs.last_drops))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    return true;
  }
  bool operator != (const partition_configuration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const partition_configuration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(partition_configuration &a, partition_configuration &b);

inline std::ostream& operator<<(std::ostream& out, const partition_configuration& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_configuration__isset {
  _replica_configuration__isset() : gpid(false), ballot(false), primary(false), status(true), learner_signature(false) {}
  bool gpid :1;
  bool ballot :1;
  bool primary :1;
  bool status :1;
  bool learner_signature :1;
} _replica_configuration__isset;

class replica_configuration {
 public:

  replica_configuration(const replica_configuration&);
  replica_configuration& operator=(const replica_configuration&);
  replica_configuration() : ballot(0), status((partition_status)0), learner_signature(0) {
    status = (partition_status)0;

  }

  virtual ~replica_configuration() throw();
  global_partition_id gpid;
  int64_t ballot;
   ::dsn::rpc_address primary;
  partition_status status;
  int64_t learner_signature;

  _replica_configuration__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_ballot(const int64_t val);

  void __set_primary(const  ::dsn::rpc_address& val);

  void __set_status(const partition_status val);

  void __set_learner_signature(const int64_t val);

  bool operator == (const replica_configuration & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(primary == rhs.primary))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(learner_signature == rhs.learner_signature))
      return false;
    return true;
  }
  bool operator != (const replica_configuration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_configuration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_configuration &a, replica_configuration &b);

inline std::ostream& operator<<(std::ostream& out, const replica_configuration& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _prepare_msg__isset {
  _prepare_msg__isset() : config(false), mu(false) {}
  bool config :1;
  bool mu :1;
} _prepare_msg__isset;

class prepare_msg {
 public:

  prepare_msg(const prepare_msg&);
  prepare_msg& operator=(const prepare_msg&);
  prepare_msg() {
  }

  virtual ~prepare_msg() throw();
  replica_configuration config;
  mutation_data mu;

  _prepare_msg__isset __isset;

  void __set_config(const replica_configuration& val);

  void __set_mu(const mutation_data& val);

  bool operator == (const prepare_msg & rhs) const
  {
    if (!(config == rhs.config))
      return false;
    if (!(mu == rhs.mu))
      return false;
    return true;
  }
  bool operator != (const prepare_msg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const prepare_msg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(prepare_msg &a, prepare_msg &b);

inline std::ostream& operator<<(std::ostream& out, const prepare_msg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _read_request_header__isset {
  _read_request_header__isset() : gpid(false), code(false), semantic(true), version_decree(true) {}
  bool gpid :1;
  bool code :1;
  bool semantic :1;
  bool version_decree :1;
} _read_request_header__isset;

class read_request_header {
 public:

  read_request_header(const read_request_header&);
  read_request_header& operator=(const read_request_header&);
  read_request_header() : semantic((read_semantic)1), version_decree(-1LL) {
    semantic = (read_semantic)1;

  }

  virtual ~read_request_header() throw();
  global_partition_id gpid;
   ::dsn::task_code code;
  read_semantic semantic;
  int64_t version_decree;

  _read_request_header__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_code(const  ::dsn::task_code& val);

  void __set_semantic(const read_semantic val);

  void __set_version_decree(const int64_t val);

  bool operator == (const read_request_header & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(semantic == rhs.semantic))
      return false;
    if (!(version_decree == rhs.version_decree))
      return false;
    return true;
  }
  bool operator != (const read_request_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const read_request_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(read_request_header &a, read_request_header &b);

inline std::ostream& operator<<(std::ostream& out, const read_request_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _write_request_header__isset {
  _write_request_header__isset() : gpid(false), code(false) {}
  bool gpid :1;
  bool code :1;
} _write_request_header__isset;

class write_request_header {
 public:

  write_request_header(const write_request_header&);
  write_request_header& operator=(const write_request_header&);
  write_request_header() {
  }

  virtual ~write_request_header() throw();
  global_partition_id gpid;
   ::dsn::task_code code;

  _write_request_header__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_code(const  ::dsn::task_code& val);

  bool operator == (const write_request_header & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(code == rhs.code))
      return false;
    return true;
  }
  bool operator != (const write_request_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const write_request_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(write_request_header &a, write_request_header &b);

inline std::ostream& operator<<(std::ostream& out, const write_request_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _rw_response_header__isset {
  _rw_response_header__isset() : err(false) {}
  bool err :1;
} _rw_response_header__isset;

class rw_response_header {
 public:

  rw_response_header(const rw_response_header&);
  rw_response_header& operator=(const rw_response_header&);
  rw_response_header() {
  }

  virtual ~rw_response_header() throw();
   ::dsn::error_code err;

  _rw_response_header__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const rw_response_header & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const rw_response_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rw_response_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(rw_response_header &a, rw_response_header &b);

inline std::ostream& operator<<(std::ostream& out, const rw_response_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _prepare_ack__isset {
  _prepare_ack__isset() : gpid(false), err(false), ballot(false), decree(false), last_committed_decree_in_app(false), last_committed_decree_in_prepare_list(false) {}
  bool gpid :1;
  bool err :1;
  bool ballot :1;
  bool decree :1;
  bool last_committed_decree_in_app :1;
  bool last_committed_decree_in_prepare_list :1;
} _prepare_ack__isset;

class prepare_ack {
 public:

  prepare_ack(const prepare_ack&);
  prepare_ack& operator=(const prepare_ack&);
  prepare_ack() : ballot(0), decree(0), last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0) {
  }

  virtual ~prepare_ack() throw();
  global_partition_id gpid;
   ::dsn::error_code err;
  int64_t ballot;
  int64_t decree;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;

  _prepare_ack__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_err(const  ::dsn::error_code& val);

  void __set_ballot(const int64_t val);

  void __set_decree(const int64_t val);

  void __set_last_committed_decree_in_app(const int64_t val);

  void __set_last_committed_decree_in_prepare_list(const int64_t val);

  bool operator == (const prepare_ack & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(err == rhs.err))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(decree == rhs.decree))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    return true;
  }
  bool operator != (const prepare_ack &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const prepare_ack & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(prepare_ack &a, prepare_ack &b);

inline std::ostream& operator<<(std::ostream& out, const prepare_ack& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _learn_state__isset {
  _learn_state__isset() : from_decree_excluded(false), to_decree_included(false), meta(false), files(false) {}
  bool from_decree_excluded :1;
  bool to_decree_included :1;
  bool meta :1;
  bool files :1;
} _learn_state__isset;

class learn_state {
 public:

  learn_state(const learn_state&);
  learn_state& operator=(const learn_state&);
  learn_state() : from_decree_excluded(0), to_decree_included(0) {
  }

  virtual ~learn_state() throw();
  int64_t from_decree_excluded;
  int64_t to_decree_included;
  std::vector< ::dsn::blob>  meta;
  std::vector<std::string>  files;

  _learn_state__isset __isset;

  void __set_from_decree_excluded(const int64_t val);

  void __set_to_decree_included(const int64_t val);

  void __set_meta(const std::vector< ::dsn::blob> & val);

  void __set_files(const std::vector<std::string> & val);

  bool operator == (const learn_state & rhs) const
  {
    if (!(from_decree_excluded == rhs.from_decree_excluded))
      return false;
    if (!(to_decree_included == rhs.to_decree_included))
      return false;
    if (!(meta == rhs.meta))
      return false;
    if (!(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const learn_state &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_state & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(learn_state &a, learn_state &b);

inline std::ostream& operator<<(std::ostream& out, const learn_state& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _learn_request__isset {
  _learn_request__isset() : gpid(false), learner(false), signature(false), last_committed_decree_in_app(false), last_committed_decree_in_prepare_list(false), app_specific_learn_request(false) {}
  bool gpid :1;
  bool learner :1;
  bool signature :1;
  bool last_committed_decree_in_app :1;
  bool last_committed_decree_in_prepare_list :1;
  bool app_specific_learn_request :1;
} _learn_request__isset;

class learn_request {
 public:

  learn_request(const learn_request&);
  learn_request& operator=(const learn_request&);
  learn_request() : signature(0), last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0) {
  }

  virtual ~learn_request() throw();
  global_partition_id gpid;
   ::dsn::rpc_address learner;
  int64_t signature;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;
   ::dsn::blob app_specific_learn_request;

  _learn_request__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_learner(const  ::dsn::rpc_address& val);

  void __set_signature(const int64_t val);

  void __set_last_committed_decree_in_app(const int64_t val);

  void __set_last_committed_decree_in_prepare_list(const int64_t val);

  void __set_app_specific_learn_request(const  ::dsn::blob& val);

  bool operator == (const learn_request & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(learner == rhs.learner))
      return false;
    if (!(signature == rhs.signature))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    if (!(app_specific_learn_request == rhs.app_specific_learn_request))
      return false;
    return true;
  }
  bool operator != (const learn_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(learn_request &a, learn_request &b);

inline std::ostream& operator<<(std::ostream& out, const learn_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _learn_response__isset {
  _learn_response__isset() : err(false), config(false), last_committed_decree(false), prepare_start_decree(false), type(true), state(false), address(false), base_local_dir(false) {}
  bool err :1;
  bool config :1;
  bool last_committed_decree :1;
  bool prepare_start_decree :1;
  bool type :1;
  bool state :1;
  bool address :1;
  bool base_local_dir :1;
} _learn_response__isset;

class learn_response {
 public:

  learn_response(const learn_response&);
  learn_response& operator=(const learn_response&);
  learn_response() : last_committed_decree(0), prepare_start_decree(0), type((learn_type)0), base_local_dir() {
    type = (learn_type)0;

  }

  virtual ~learn_response() throw();
   ::dsn::error_code err;
  replica_configuration config;
  int64_t last_committed_decree;
  int64_t prepare_start_decree;
  learn_type type;
  learn_state state;
   ::dsn::rpc_address address;
  std::string base_local_dir;

  _learn_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_config(const replica_configuration& val);

  void __set_last_committed_decree(const int64_t val);

  void __set_prepare_start_decree(const int64_t val);

  void __set_type(const learn_type val);

  void __set_state(const learn_state& val);

  void __set_address(const  ::dsn::rpc_address& val);

  void __set_base_local_dir(const std::string& val);

  bool operator == (const learn_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(config == rhs.config))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    if (!(prepare_start_decree == rhs.prepare_start_decree))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(base_local_dir == rhs.base_local_dir))
      return false;
    return true;
  }
  bool operator != (const learn_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(learn_response &a, learn_response &b);

inline std::ostream& operator<<(std::ostream& out, const learn_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _group_check_request__isset {
  _group_check_request__isset() : app_type(false), node(false), config(false), last_committed_decree(false) {}
  bool app_type :1;
  bool node :1;
  bool config :1;
  bool last_committed_decree :1;
} _group_check_request__isset;

class group_check_request {
 public:

  group_check_request(const group_check_request&);
  group_check_request& operator=(const group_check_request&);
  group_check_request() : app_type(), last_committed_decree(0) {
  }

  virtual ~group_check_request() throw();
  std::string app_type;
   ::dsn::rpc_address node;
  replica_configuration config;
  int64_t last_committed_decree;

  _group_check_request__isset __isset;

  void __set_app_type(const std::string& val);

  void __set_node(const  ::dsn::rpc_address& val);

  void __set_config(const replica_configuration& val);

  void __set_last_committed_decree(const int64_t val);

  bool operator == (const group_check_request & rhs) const
  {
    if (!(app_type == rhs.app_type))
      return false;
    if (!(node == rhs.node))
      return false;
    if (!(config == rhs.config))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    return true;
  }
  bool operator != (const group_check_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const group_check_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(group_check_request &a, group_check_request &b);

inline std::ostream& operator<<(std::ostream& out, const group_check_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _group_check_response__isset {
  _group_check_response__isset() : gpid(false), err(false), last_committed_decree_in_app(false), last_committed_decree_in_prepare_list(false), learner_status_(true), learner_signature(false), node(false) {}
  bool gpid :1;
  bool err :1;
  bool last_committed_decree_in_app :1;
  bool last_committed_decree_in_prepare_list :1;
  bool learner_status_ :1;
  bool learner_signature :1;
  bool node :1;
} _group_check_response__isset;

class group_check_response {
 public:

  group_check_response(const group_check_response&);
  group_check_response& operator=(const group_check_response&);
  group_check_response() : last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0), learner_status_((learner_status)0), learner_signature(0) {
    learner_status_ = (learner_status)0;

  }

  virtual ~group_check_response() throw();
  global_partition_id gpid;
   ::dsn::error_code err;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;
  learner_status learner_status_;
  int64_t learner_signature;
   ::dsn::rpc_address node;

  _group_check_response__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_err(const  ::dsn::error_code& val);

  void __set_last_committed_decree_in_app(const int64_t val);

  void __set_last_committed_decree_in_prepare_list(const int64_t val);

  void __set_learner_status_(const learner_status val);

  void __set_learner_signature(const int64_t val);

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const group_check_response & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(err == rhs.err))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    if (!(learner_status_ == rhs.learner_status_))
      return false;
    if (!(learner_signature == rhs.learner_signature))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const group_check_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const group_check_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(group_check_response &a, group_check_response &b);

inline std::ostream& operator<<(std::ostream& out, const group_check_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _app_info__isset {
  _app_info__isset() : status(true), app_type(false), app_name(false), app_id(false), partition_count(false) {}
  bool status :1;
  bool app_type :1;
  bool app_name :1;
  bool app_id :1;
  bool partition_count :1;
} _app_info__isset;

class app_info {
 public:

  app_info(const app_info&);
  app_info& operator=(const app_info&);
  app_info() : status((app_status)0), app_type(), app_name(), app_id(0), partition_count(0) {
    status = (app_status)0;

  }

  virtual ~app_info() throw();
  app_status status;
  std::string app_type;
  std::string app_name;
  int32_t app_id;
  int32_t partition_count;

  _app_info__isset __isset;

  void __set_status(const app_status val);

  void __set_app_type(const std::string& val);

  void __set_app_name(const std::string& val);

  void __set_app_id(const int32_t val);

  void __set_partition_count(const int32_t val);

  bool operator == (const app_info & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(app_type == rhs.app_type))
      return false;
    if (!(app_name == rhs.app_name))
      return false;
    if (!(app_id == rhs.app_id))
      return false;
    if (!(partition_count == rhs.partition_count))
      return false;
    return true;
  }
  bool operator != (const app_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const app_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(app_info &a, app_info &b);

inline std::ostream& operator<<(std::ostream& out, const app_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _node_info__isset {
  _node_info__isset() : status(true), address(false) {}
  bool status :1;
  bool address :1;
} _node_info__isset;

class node_info {
 public:

  node_info(const node_info&);
  node_info& operator=(const node_info&);
  node_info() : status((node_status)0) {
    status = (node_status)0;

  }

  virtual ~node_info() throw();
  node_status status;
   ::dsn::rpc_address address;

  _node_info__isset __isset;

  void __set_status(const node_status val);

  void __set_address(const  ::dsn::rpc_address& val);

  bool operator == (const node_info & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const node_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const node_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(node_info &a, node_info &b);

inline std::ostream& operator<<(std::ostream& out, const node_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _meta_response_header__isset {
  _meta_response_header__isset() : err(false), primary_address(false) {}
  bool err :1;
  bool primary_address :1;
} _meta_response_header__isset;

class meta_response_header {
 public:

  meta_response_header(const meta_response_header&);
  meta_response_header& operator=(const meta_response_header&);
  meta_response_header() {
  }

  virtual ~meta_response_header() throw();
   ::dsn::error_code err;
   ::dsn::rpc_address primary_address;

  _meta_response_header__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_primary_address(const  ::dsn::rpc_address& val);

  bool operator == (const meta_response_header & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(primary_address == rhs.primary_address))
      return false;
    return true;
  }
  bool operator != (const meta_response_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const meta_response_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(meta_response_header &a, meta_response_header &b);

inline std::ostream& operator<<(std::ostream& out, const meta_response_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_update_request__isset {
  _configuration_update_request__isset() : config(false), type(true), node(false) {}
  bool config :1;
  bool type :1;
  bool node :1;
} _configuration_update_request__isset;

class configuration_update_request {
 public:

  configuration_update_request(const configuration_update_request&);
  configuration_update_request& operator=(const configuration_update_request&);
  configuration_update_request() : type((config_type)0) {
    type = (config_type)0;

  }

  virtual ~configuration_update_request() throw();
  partition_configuration config;
  config_type type;
   ::dsn::rpc_address node;

  _configuration_update_request__isset __isset;

  void __set_config(const partition_configuration& val);

  void __set_type(const config_type val);

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const configuration_update_request & rhs) const
  {
    if (!(config == rhs.config))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const configuration_update_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_update_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_update_request &a, configuration_update_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_update_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_update_response__isset {
  _configuration_update_response__isset() : err(false), config(false) {}
  bool err :1;
  bool config :1;
} _configuration_update_response__isset;

class configuration_update_response {
 public:

  configuration_update_response(const configuration_update_response&);
  configuration_update_response& operator=(const configuration_update_response&);
  configuration_update_response() {
  }

  virtual ~configuration_update_response() throw();
   ::dsn::error_code err;
  partition_configuration config;

  _configuration_update_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_config(const partition_configuration& val);

  bool operator == (const configuration_update_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(config == rhs.config))
      return false;
    return true;
  }
  bool operator != (const configuration_update_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_update_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_update_response &a, configuration_update_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_update_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_proposal_request__isset {
  _configuration_proposal_request__isset() : config(false), type(true), node(false), is_clean_data(true), is_upgrade(true) {}
  bool config :1;
  bool type :1;
  bool node :1;
  bool is_clean_data :1;
  bool is_upgrade :1;
} _configuration_proposal_request__isset;

class configuration_proposal_request {
 public:

  configuration_proposal_request(const configuration_proposal_request&);
  configuration_proposal_request& operator=(const configuration_proposal_request&);
  configuration_proposal_request() : type((config_type)0), is_clean_data(false), is_upgrade(false) {
    type = (config_type)0;

  }

  virtual ~configuration_proposal_request() throw();
  partition_configuration config;
  config_type type;
   ::dsn::rpc_address node;
  bool is_clean_data;
  bool is_upgrade;

  _configuration_proposal_request__isset __isset;

  void __set_config(const partition_configuration& val);

  void __set_type(const config_type val);

  void __set_node(const  ::dsn::rpc_address& val);

  void __set_is_clean_data(const bool val);

  void __set_is_upgrade(const bool val);

  bool operator == (const configuration_proposal_request & rhs) const
  {
    if (!(config == rhs.config))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(node == rhs.node))
      return false;
    if (!(is_clean_data == rhs.is_clean_data))
      return false;
    if (!(is_upgrade == rhs.is_upgrade))
      return false;
    return true;
  }
  bool operator != (const configuration_proposal_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_proposal_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_proposal_request &a, configuration_proposal_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_proposal_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_query_by_node_request__isset {
  _configuration_query_by_node_request__isset() : node(false) {}
  bool node :1;
} _configuration_query_by_node_request__isset;

class configuration_query_by_node_request {
 public:

  configuration_query_by_node_request(const configuration_query_by_node_request&);
  configuration_query_by_node_request& operator=(const configuration_query_by_node_request&);
  configuration_query_by_node_request() {
  }

  virtual ~configuration_query_by_node_request() throw();
   ::dsn::rpc_address node;

  _configuration_query_by_node_request__isset __isset;

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const configuration_query_by_node_request & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_node_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_node_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_query_by_node_request &a, configuration_query_by_node_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_query_by_node_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _create_app_options__isset {
  _create_app_options__isset() : partition_count(false), replica_count(false), success_if_exist(false), app_type(false) {}
  bool partition_count :1;
  bool replica_count :1;
  bool success_if_exist :1;
  bool app_type :1;
} _create_app_options__isset;

class create_app_options {
 public:

  create_app_options(const create_app_options&);
  create_app_options& operator=(const create_app_options&);
  create_app_options() : partition_count(0), replica_count(0), success_if_exist(0), app_type() {
  }

  virtual ~create_app_options() throw();
  int32_t partition_count;
  int32_t replica_count;
  bool success_if_exist;
  std::string app_type;

  _create_app_options__isset __isset;

  void __set_partition_count(const int32_t val);

  void __set_replica_count(const int32_t val);

  void __set_success_if_exist(const bool val);

  void __set_app_type(const std::string& val);

  bool operator == (const create_app_options & rhs) const
  {
    if (!(partition_count == rhs.partition_count))
      return false;
    if (!(replica_count == rhs.replica_count))
      return false;
    if (!(success_if_exist == rhs.success_if_exist))
      return false;
    if (!(app_type == rhs.app_type))
      return false;
    return true;
  }
  bool operator != (const create_app_options &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const create_app_options & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(create_app_options &a, create_app_options &b);

inline std::ostream& operator<<(std::ostream& out, const create_app_options& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_create_app_request__isset {
  _configuration_create_app_request__isset() : app_name(false), options(false) {}
  bool app_name :1;
  bool options :1;
} _configuration_create_app_request__isset;

class configuration_create_app_request {
 public:

  configuration_create_app_request(const configuration_create_app_request&);
  configuration_create_app_request& operator=(const configuration_create_app_request&);
  configuration_create_app_request() : app_name() {
  }

  virtual ~configuration_create_app_request() throw();
  std::string app_name;
  create_app_options options;

  _configuration_create_app_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_options(const create_app_options& val);

  bool operator == (const configuration_create_app_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const configuration_create_app_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_create_app_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_create_app_request &a, configuration_create_app_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_create_app_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _drop_app_options__isset {
  _drop_app_options__isset() : success_if_not_exist(false) {}
  bool success_if_not_exist :1;
} _drop_app_options__isset;

class drop_app_options {
 public:

  drop_app_options(const drop_app_options&);
  drop_app_options& operator=(const drop_app_options&);
  drop_app_options() : success_if_not_exist(0) {
  }

  virtual ~drop_app_options() throw();
  bool success_if_not_exist;

  _drop_app_options__isset __isset;

  void __set_success_if_not_exist(const bool val);

  bool operator == (const drop_app_options & rhs) const
  {
    if (!(success_if_not_exist == rhs.success_if_not_exist))
      return false;
    return true;
  }
  bool operator != (const drop_app_options &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const drop_app_options & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(drop_app_options &a, drop_app_options &b);

inline std::ostream& operator<<(std::ostream& out, const drop_app_options& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_drop_app_request__isset {
  _configuration_drop_app_request__isset() : app_name(false), options(false) {}
  bool app_name :1;
  bool options :1;
} _configuration_drop_app_request__isset;

class configuration_drop_app_request {
 public:

  configuration_drop_app_request(const configuration_drop_app_request&);
  configuration_drop_app_request& operator=(const configuration_drop_app_request&);
  configuration_drop_app_request() : app_name() {
  }

  virtual ~configuration_drop_app_request() throw();
  std::string app_name;
  drop_app_options options;

  _configuration_drop_app_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_options(const drop_app_options& val);

  bool operator == (const configuration_drop_app_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const configuration_drop_app_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_drop_app_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_drop_app_request &a, configuration_drop_app_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_drop_app_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_apps_request__isset {
  _configuration_list_apps_request__isset() : status(true) {}
  bool status :1;
} _configuration_list_apps_request__isset;

class configuration_list_apps_request {
 public:

  configuration_list_apps_request(const configuration_list_apps_request&);
  configuration_list_apps_request& operator=(const configuration_list_apps_request&);
  configuration_list_apps_request() : status((app_status)0) {
    status = (app_status)0;

  }

  virtual ~configuration_list_apps_request() throw();
  app_status status;

  _configuration_list_apps_request__isset __isset;

  void __set_status(const app_status val);

  bool operator == (const configuration_list_apps_request & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const configuration_list_apps_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_apps_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_apps_request &a, configuration_list_apps_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_apps_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_nodes_request__isset {
  _configuration_list_nodes_request__isset() : status(true) {}
  bool status :1;
} _configuration_list_nodes_request__isset;

class configuration_list_nodes_request {
 public:

  configuration_list_nodes_request(const configuration_list_nodes_request&);
  configuration_list_nodes_request& operator=(const configuration_list_nodes_request&);
  configuration_list_nodes_request() : status((node_status)0) {
    status = (node_status)0;

  }

  virtual ~configuration_list_nodes_request() throw();
  node_status status;

  _configuration_list_nodes_request__isset __isset;

  void __set_status(const node_status val);

  bool operator == (const configuration_list_nodes_request & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const configuration_list_nodes_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_nodes_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_nodes_request &a, configuration_list_nodes_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_nodes_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_create_app_response__isset {
  _configuration_create_app_response__isset() : err(false), appid(false) {}
  bool err :1;
  bool appid :1;
} _configuration_create_app_response__isset;

class configuration_create_app_response {
 public:

  configuration_create_app_response(const configuration_create_app_response&);
  configuration_create_app_response& operator=(const configuration_create_app_response&);
  configuration_create_app_response() : appid(0) {
  }

  virtual ~configuration_create_app_response() throw();
   ::dsn::error_code err;
  int32_t appid;

  _configuration_create_app_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_appid(const int32_t val);

  bool operator == (const configuration_create_app_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(appid == rhs.appid))
      return false;
    return true;
  }
  bool operator != (const configuration_create_app_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_create_app_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_create_app_response &a, configuration_create_app_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_create_app_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _control_balancer_migration_request__isset {
  _control_balancer_migration_request__isset() : enable_migration(false) {}
  bool enable_migration :1;
} _control_balancer_migration_request__isset;

class control_balancer_migration_request {
 public:

  control_balancer_migration_request(const control_balancer_migration_request&);
  control_balancer_migration_request& operator=(const control_balancer_migration_request&);
  control_balancer_migration_request() : enable_migration(0) {
  }

  virtual ~control_balancer_migration_request() throw();
  bool enable_migration;

  _control_balancer_migration_request__isset __isset;

  void __set_enable_migration(const bool val);

  bool operator == (const control_balancer_migration_request & rhs) const
  {
    if (!(enable_migration == rhs.enable_migration))
      return false;
    return true;
  }
  bool operator != (const control_balancer_migration_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const control_balancer_migration_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(control_balancer_migration_request &a, control_balancer_migration_request &b);

inline std::ostream& operator<<(std::ostream& out, const control_balancer_migration_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _control_balancer_migration_response__isset {
  _control_balancer_migration_response__isset() : err(false) {}
  bool err :1;
} _control_balancer_migration_response__isset;

class control_balancer_migration_response {
 public:

  control_balancer_migration_response(const control_balancer_migration_response&);
  control_balancer_migration_response& operator=(const control_balancer_migration_response&);
  control_balancer_migration_response() {
  }

  virtual ~control_balancer_migration_response() throw();
   ::dsn::error_code err;

  _control_balancer_migration_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const control_balancer_migration_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const control_balancer_migration_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const control_balancer_migration_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(control_balancer_migration_response &a, control_balancer_migration_response &b);

inline std::ostream& operator<<(std::ostream& out, const control_balancer_migration_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _balancer_proposal_request__isset {
  _balancer_proposal_request__isset() : gpid(false), type(false), from_addr(false), to_addr(false) {}
  bool gpid :1;
  bool type :1;
  bool from_addr :1;
  bool to_addr :1;
} _balancer_proposal_request__isset;

class balancer_proposal_request {
 public:

  balancer_proposal_request(const balancer_proposal_request&);
  balancer_proposal_request& operator=(const balancer_proposal_request&);
  balancer_proposal_request() : type((balancer_type)0) {
  }

  virtual ~balancer_proposal_request() throw();
  global_partition_id gpid;
  balancer_type type;
   ::dsn::rpc_address from_addr;
   ::dsn::rpc_address to_addr;

  _balancer_proposal_request__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_type(const balancer_type val);

  void __set_from_addr(const  ::dsn::rpc_address& val);

  void __set_to_addr(const  ::dsn::rpc_address& val);

  bool operator == (const balancer_proposal_request & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(from_addr == rhs.from_addr))
      return false;
    if (!(to_addr == rhs.to_addr))
      return false;
    return true;
  }
  bool operator != (const balancer_proposal_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const balancer_proposal_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(balancer_proposal_request &a, balancer_proposal_request &b);

inline std::ostream& operator<<(std::ostream& out, const balancer_proposal_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _balancer_proposal_response__isset {
  _balancer_proposal_response__isset() : err(false) {}
  bool err :1;
} _balancer_proposal_response__isset;

class balancer_proposal_response {
 public:

  balancer_proposal_response(const balancer_proposal_response&);
  balancer_proposal_response& operator=(const balancer_proposal_response&);
  balancer_proposal_response() {
  }

  virtual ~balancer_proposal_response() throw();
   ::dsn::error_code err;

  _balancer_proposal_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const balancer_proposal_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const balancer_proposal_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const balancer_proposal_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(balancer_proposal_response &a, balancer_proposal_response &b);

inline std::ostream& operator<<(std::ostream& out, const balancer_proposal_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_drop_app_response__isset {
  _configuration_drop_app_response__isset() : err(false) {}
  bool err :1;
} _configuration_drop_app_response__isset;

class configuration_drop_app_response {
 public:

  configuration_drop_app_response(const configuration_drop_app_response&);
  configuration_drop_app_response& operator=(const configuration_drop_app_response&);
  configuration_drop_app_response() {
  }

  virtual ~configuration_drop_app_response() throw();
   ::dsn::error_code err;

  _configuration_drop_app_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const configuration_drop_app_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const configuration_drop_app_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_drop_app_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_drop_app_response &a, configuration_drop_app_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_drop_app_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_apps_response__isset {
  _configuration_list_apps_response__isset() : err(false), infos(false) {}
  bool err :1;
  bool infos :1;
} _configuration_list_apps_response__isset;

class configuration_list_apps_response {
 public:

  configuration_list_apps_response(const configuration_list_apps_response&);
  configuration_list_apps_response& operator=(const configuration_list_apps_response&);
  configuration_list_apps_response() {
  }

  virtual ~configuration_list_apps_response() throw();
   ::dsn::error_code err;
  std::vector<app_info>  infos;

  _configuration_list_apps_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_infos(const std::vector<app_info> & val);

  bool operator == (const configuration_list_apps_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(infos == rhs.infos))
      return false;
    return true;
  }
  bool operator != (const configuration_list_apps_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_apps_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_apps_response &a, configuration_list_apps_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_apps_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_nodes_response__isset {
  _configuration_list_nodes_response__isset() : err(false), infos(false) {}
  bool err :1;
  bool infos :1;
} _configuration_list_nodes_response__isset;

class configuration_list_nodes_response {
 public:

  configuration_list_nodes_response(const configuration_list_nodes_response&);
  configuration_list_nodes_response& operator=(const configuration_list_nodes_response&);
  configuration_list_nodes_response() {
  }

  virtual ~configuration_list_nodes_response() throw();
   ::dsn::error_code err;
  std::vector<node_info>  infos;

  _configuration_list_nodes_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_infos(const std::vector<node_info> & val);

  bool operator == (const configuration_list_nodes_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(infos == rhs.infos))
      return false;
    return true;
  }
  bool operator != (const configuration_list_nodes_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_nodes_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_nodes_response &a, configuration_list_nodes_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_nodes_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_query_by_node_response__isset {
  _configuration_query_by_node_response__isset() : err(false), partitions(false) {}
  bool err :1;
  bool partitions :1;
} _configuration_query_by_node_response__isset;

class configuration_query_by_node_response {
 public:

  configuration_query_by_node_response(const configuration_query_by_node_response&);
  configuration_query_by_node_response& operator=(const configuration_query_by_node_response&);
  configuration_query_by_node_response() {
  }

  virtual ~configuration_query_by_node_response() throw();
   ::dsn::error_code err;
  std::vector<partition_configuration>  partitions;

  _configuration_query_by_node_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_partitions(const std::vector<partition_configuration> & val);

  bool operator == (const configuration_query_by_node_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_node_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_node_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_query_by_node_response &a, configuration_query_by_node_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_query_by_node_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_query_by_index_request__isset {
  _configuration_query_by_index_request__isset() : app_name(false), partition_indices(false) {}
  bool app_name :1;
  bool partition_indices :1;
} _configuration_query_by_index_request__isset;

class configuration_query_by_index_request {
 public:

  configuration_query_by_index_request(const configuration_query_by_index_request&);
  configuration_query_by_index_request& operator=(const configuration_query_by_index_request&);
  configuration_query_by_index_request() : app_name() {
  }

  virtual ~configuration_query_by_index_request() throw();
  std::string app_name;
  std::vector<int32_t>  partition_indices;

  _configuration_query_by_index_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_partition_indices(const std::vector<int32_t> & val);

  bool operator == (const configuration_query_by_index_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(partition_indices == rhs.partition_indices))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_index_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_index_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_query_by_index_request &a, configuration_query_by_index_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_query_by_index_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_query_by_index_response__isset {
  _configuration_query_by_index_response__isset() : err(false), app_id(false), partition_count(false), partitions(false) {}
  bool err :1;
  bool app_id :1;
  bool partition_count :1;
  bool partitions :1;
} _configuration_query_by_index_response__isset;

class configuration_query_by_index_response {
 public:

  configuration_query_by_index_response(const configuration_query_by_index_response&);
  configuration_query_by_index_response& operator=(const configuration_query_by_index_response&);
  configuration_query_by_index_response() : app_id(0), partition_count(0) {
  }

  virtual ~configuration_query_by_index_response() throw();
   ::dsn::error_code err;
  int32_t app_id;
  int32_t partition_count;
  std::vector<partition_configuration>  partitions;

  _configuration_query_by_index_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_app_id(const int32_t val);

  void __set_partition_count(const int32_t val);

  void __set_partitions(const std::vector<partition_configuration> & val);

  bool operator == (const configuration_query_by_index_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(app_id == rhs.app_id))
      return false;
    if (!(partition_count == rhs.partition_count))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_index_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_index_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_query_by_index_response &a, configuration_query_by_index_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_query_by_index_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_decree_request__isset {
  _query_replica_decree_request__isset() : gpid(false), node(false) {}
  bool gpid :1;
  bool node :1;
} _query_replica_decree_request__isset;

class query_replica_decree_request {
 public:

  query_replica_decree_request(const query_replica_decree_request&);
  query_replica_decree_request& operator=(const query_replica_decree_request&);
  query_replica_decree_request() {
  }

  virtual ~query_replica_decree_request() throw();
  global_partition_id gpid;
   ::dsn::rpc_address node;

  _query_replica_decree_request__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const query_replica_decree_request & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const query_replica_decree_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_decree_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_decree_request &a, query_replica_decree_request &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_decree_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_decree_response__isset {
  _query_replica_decree_response__isset() : err(false), last_decree(false) {}
  bool err :1;
  bool last_decree :1;
} _query_replica_decree_response__isset;

class query_replica_decree_response {
 public:

  query_replica_decree_response(const query_replica_decree_response&);
  query_replica_decree_response& operator=(const query_replica_decree_response&);
  query_replica_decree_response() : last_decree(0) {
  }

  virtual ~query_replica_decree_response() throw();
   ::dsn::error_code err;
  int64_t last_decree;

  _query_replica_decree_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_last_decree(const int64_t val);

  bool operator == (const query_replica_decree_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(last_decree == rhs.last_decree))
      return false;
    return true;
  }
  bool operator != (const query_replica_decree_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_decree_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_decree_response &a, query_replica_decree_response &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_decree_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_info__isset {
  _replica_info__isset() : gpid(false), ballot(false), status(false), last_committed_decree(false), last_prepared_decree(false), last_durable_decree(false) {}
  bool gpid :1;
  bool ballot :1;
  bool status :1;
  bool last_committed_decree :1;
  bool last_prepared_decree :1;
  bool last_durable_decree :1;
} _replica_info__isset;

class replica_info {
 public:

  replica_info(const replica_info&);
  replica_info& operator=(const replica_info&);
  replica_info() : ballot(0), status((partition_status)0), last_committed_decree(0), last_prepared_decree(0), last_durable_decree(0) {
  }

  virtual ~replica_info() throw();
  global_partition_id gpid;
  int64_t ballot;
  partition_status status;
  int64_t last_committed_decree;
  int64_t last_prepared_decree;
  int64_t last_durable_decree;

  _replica_info__isset __isset;

  void __set_gpid(const global_partition_id& val);

  void __set_ballot(const int64_t val);

  void __set_status(const partition_status val);

  void __set_last_committed_decree(const int64_t val);

  void __set_last_prepared_decree(const int64_t val);

  void __set_last_durable_decree(const int64_t val);

  bool operator == (const replica_info & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    if (!(last_prepared_decree == rhs.last_prepared_decree))
      return false;
    if (!(last_durable_decree == rhs.last_durable_decree))
      return false;
    return true;
  }
  bool operator != (const replica_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_info &a, replica_info &b);

inline std::ostream& operator<<(std::ostream& out, const replica_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_info_request__isset {
  _query_replica_info_request__isset() : node(false) {}
  bool node :1;
} _query_replica_info_request__isset;

class query_replica_info_request {
 public:

  query_replica_info_request(const query_replica_info_request&);
  query_replica_info_request& operator=(const query_replica_info_request&);
  query_replica_info_request() {
  }

  virtual ~query_replica_info_request() throw();
   ::dsn::rpc_address node;

  _query_replica_info_request__isset __isset;

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const query_replica_info_request & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const query_replica_info_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_info_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_info_request &a, query_replica_info_request &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_info_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_info_response__isset {
  _query_replica_info_response__isset() : err(false), replicas(false) {}
  bool err :1;
  bool replicas :1;
} _query_replica_info_response__isset;

class query_replica_info_response {
 public:

  query_replica_info_response(const query_replica_info_response&);
  query_replica_info_response& operator=(const query_replica_info_response&);
  query_replica_info_response() {
  }

  virtual ~query_replica_info_response() throw();
   ::dsn::error_code err;
  std::vector<replica_info>  replicas;

  _query_replica_info_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_replicas(const std::vector<replica_info> & val);

  bool operator == (const query_replica_info_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(replicas == rhs.replicas))
      return false;
    return true;
  }
  bool operator != (const query_replica_info_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_info_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_info_response &a, query_replica_info_response &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_info_response& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
